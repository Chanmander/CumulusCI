use crate::cumulusci::{CumulusCI, Freeze};
use serde::{Deserialize, Serialize};

mod cumulusci;

// Low-level WASM API (to be generated by #[task] macro)
#[no_mangle]
pub extern "C" fn get_task_id() -> String {
    // This function compiles to WASM that returns an offset and a length into the memory.
    "rust-tasks.print-api-version".to_owned()
}

#[no_mangle]
pub extern "C" fn parse_options(json: Box<[u8]>) -> Option<Box<Options>> {
    Some(Box::new(serde_json::from_slice(&*json).unwrap()))
}

#[no_mangle]
pub extern "C" fn parse_dynamic_options(json: Box<[u8]>) -> Option<Box<Options>> {
    // WASM params are an index and offset; return is a nullable pointer
    Some(Box::new(
        serde_json::from_slice(&*json).ok()?.freeze(&CumulusCI {})?,
    ))
}

#[no_mangle]
pub extern "C" fn run_task(options: Box<Options>) -> Box<ReturnValues> {
    // WASM params are two ints; return is a nullable pointer
    let task = PrintApiVersion::new(*options);

    Box::new(task.run(&CumulusCI {}))
}

// Actual task code in idiomatic Rust
#[derive(Deserialize)]
pub struct DynamicOptions {
    pub api_version: String,
}

impl Freeze<Options> for DynamicOptions {
    fn freeze(&self, _cumulusci: &CumulusCI) -> Result<Options> {
        Options {
            api_version: self.api_version.parse()?,
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct Options {
    pub api_version: f32,
}

type ReturnValues = ();

// TODO: add macro support.
#[task(
    id="rust.print-api-version",
    dynamic_options=DynamicOptions,
    options=Options,
    return_value=ReturnValues
)]
pub struct PrintApiVersion {
    o: Options,
}

impl PrintApiVersion {
    pub fn new(o: Options) -> PrintApiVersion {
        PrintApiVersion { o }
    }

    pub fn run(&self, _cumulusci: &CumulusCI) -> ReturnValues {
        println!("I have API version {}", self.o.api_version)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    #[test]
    pub fn test_deserialize() {
        let json_bytes = "{\"api_version\": 3.5}".as_bytes();
        assert!(parse_options(json_bytes.into()).is_some());
    }
}
